# 雅礼2月4日OI总结

今天是个好日子~~   
———————————————————————— 
## A题
今天，我的OI A题终于只超时了！  
这里讲一下我的修改后的思路：  
要让 $(a + b) * c$ 最小，关键是分析c的正负对结果的影响，因为乘法的符号会直接决定最小值的走向：  
情况 1： $c$ 为正数    
此时要让 $(a + b) * c$ 最小 → 需让a + b尽可能小（负数越小、正数也越小越好）；  
情况 2：c 为负数  
此时要让 $(a + b) * c$ 最小 → 需让a + b尽可能大（正数越大、负数也越大越好）；  
情况 3： $c$ 为 $0$     
结果直接为 $0$ ，仅当上述两种情况结果都大于 $0$ 时才需要考虑。  
因此，我们只需要：   
将数组排序（方便快速取极值）；   
枚举所有可能的 “最优组合”（仅需考虑排序后数组的前 / 后几个极值，无需遍历所有组合）；   
计算所有候选组合的结果，取最小值。  
附上代码：  

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

  int n;
  cin >> n;
  int* arr = new int[n];
  for (int i = 0; i < n; ++i) {
    cin >> arr[i];
  }

  sort(arr, arr + n);

  long long c1 = (long long)(arr[0] + arr[1]) * arr[n - 1];
  long long c2 = (long long)(arr[0] + arr[n - 1]) * arr[1];
  long long c3 = (long long)(arr[0] + arr[n - 2]) * arr[n - 1];
  long long c4 = (long long)(arr[n - 1] + arr[n - 2]) * arr[0];
  long long c5 = (long long)(arr[1] + arr[n - 1]) * arr[0];
  long long c6 = (long long)(arr[0] + arr[1]) * arr[2];
  long long c7 = (long long)(arr[n - 1] + arr[n - 2]) * arr[n - 3];
  long long c8 = (long long)(arr[0] + arr[n - 2]) * arr[0];

  long long m = min({c1, c2, c3, c4, c5, c6, c7, c8});
  cout << m << "\n";
  return 0;
}
```  


## B题  
~~老师真狠~~  
这道题居然跟英雄联盟搭上了！    
我不玩游戏！  
得了，这道题愣住了！ 

## C题
看都没看+1

## D题
看都没看+2  

————————————————————————————————  
够好啦，继续努力！
