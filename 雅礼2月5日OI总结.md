# 雅礼2月5日OI总结
今天还可以……  ~~但妈妈质问了我一声~~    
————————————————————————————————————     
## A题
A题实际上还好，但代码直接WA……     
下面是我的一个改了的思路：    

首先，   
题目要求所有灯变为 1，等价于计算每个灯需要的翻转次数：   
原灯为 $0$（灭）：需要翻奇数次变 $1$ ，记翻转需求 $c[i][j] = 1$   
原灯为 $1$（亮）：需要翻偶数次（ $0$ 次）保持 $1$ ，记翻转需求 $c[i][j] = 0$   
因此问题转化为：能否通过横竖相邻翻转操作，让每个灯的实际翻转次数等于其翻转需求 $c[i][j]$ （模 2，因为翻转 2 次等价于没翻）。   

其次；   
横竖操作的共性是每次翻转两个相邻灯，因此不同场景的可行条件不同，分4 种核心场景分析（覆盖所有情况）：   
场景 1：单灯（ $n=1$ 且 $m=1$）   
无任何可执行的操作（横竖都需要两个灯），因此只有初始灯为 $1$ $（c[0][0] = 0）$ 时可行。   
场景 2：单行（ $n=1$ ， $m>1$ ）   
仅能执行横向操作（翻转相邻两灯），设横向操作 $x[j]$ 为第 $j$ 列的操作次数 $（0/1）$，推导得：   
第 $1$ 盏灯的翻转次数 $= x[1]$ ，需等于 $c[0]$      
第 $k$ 盏灯 $（2≤k≤m-1）$ 的翻转次数 $= x[k-1]+x[k]$ ，需等于 $c[k-1]$            
最后 1 盏灯的翻转次数 $= x[m-1]$ ，需等于 $c[m-1]$      
可行条件：按上述递推得到的最后一个操作次数，等于最后一盏灯的翻转需求。   
场景 3：单列 $（m=1，n>1）$     
仅能执行竖向操作（翻转相邻两灯），推导逻辑与单行完全一致：
可行条件：按竖向递推得到的最后一个操作次数，等于最后一盏灯的翻转需求。
场景 4：多行多列 $（n≥2 且 m≥2）$
此时横竖操作足够灵活，可组合出任意需要的翻转组合，唯一约束是总翻转需求为偶数（因为每个操作贡献 2 次翻转，总翻转次数必为偶数）。
可行条件：所有 $c[i][j]$ 的和模 $2$ 等于 $0$ 。

A题的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

bool Check1(string s) {
  int m = s.size();
  if (m == 1) {
    return s[0] == '1';
  }

  int x = (s[0] == '0') ? 1 : 0;
  for (int k = 1; k < m - 1; k++) {
    int need = (s[k] == '0') ? 1 : 0;
    x = need ^ x;
  }

  int lastNeed = (s.back() == '0') ? 1 : 0;
  return x == lastNeed;
}

bool Check2(int arr[], int n) {
  if (n == 1) {
    return arr[0] == 1;
  }

  int x = (arr[0] == 0) ? 1 : 0;
  for (int k = 1; k < n - 1; k++) {
    int need = (arr[k] == 0) ? 1 : 0;
    x = need ^ x;
  }
  int lastNeed = (arr[n - 1] == 0) ? 1 : 0;
  return x == lastNeed;
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

  int T;
  cin >> T;
  while (T--) {
    int n, m;
    cin >> n >> m;
    if (n == 1 && m == 1) {
      string s;
      cin >> s;
      cout << (s[0] == '1' ? "Yes" : "No") << '\n';
    } else if (n == 1) {
      string s;
      cin >> s;
      cout << (Check1(s) ? "Yes" : "No") << '\n';
    } else if (m == 1) {
      int col[2005];
      for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        col[i] = s[0] - '0';
      }
      cout << (Check2(col, n) ? "Yes" : "No") << '\n';
    } else {
      int total = 0;
      for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        for (char ch : s) {
          if (ch == '0') {
            total++;
          }
        }
      }
      cout << (total % 2 == 0 ? "Yes" : "No") << '\n';
    }
  }
  return 0;
}

```
——————————————————————————————————
## B题

算法直接运行错误！~~星星亮瞎眼~~    
又改，思路如下：
题目给出的是以 1 号节点为根的外向有向树（无环、从根出发可达所有节点、每个节点父节点唯一），要求找根出发的所有路径中字典序最大的字符串。
核心贪心策略：从根节点开始，每一步都选择「后续路径字典序最大」的子节点，直到无节点可走。为了实现这个策略，需要后序遍历树（从叶子到根），为每个节点记录最优后继节点（下一步该走的节点），最后从根沿最优后继拼接字符即可。
关键优化点
不存完整路径：若存每个节点的完整路径，n=1e6 时会内存爆炸，仅用一个数组记录「最优后继节点」，空间复杂度 O (n)。
非递归后序遍历：递归遍历 1e6 规模的树会栈溢出，必须用栈实现非递归后序。
高效路径比较：比较两个子节点的后续路径时，利用已记录的最优后继模拟逐位比较，均摊时间复杂度 O (1)，整体算法时间复杂度 O (n)。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 1000005

int n;
char s[MAXN];
vector<int> adj[MAXN];
int nxt[MAXN];
bool vis[MAXN];

bool cmp(int a, int b) {
  int p = a, q = b;
  while (p != -1 && q != -1) {
    if (s[p] > s[q]) return true;
    if (s[p] < s[q]) return false;
    p = nxt[p];
    q = nxt[q];
  }

  return p != -1;
}

void postOrder() {
  stack<pair<int, bool>> st;
  st.push({1, false});
  memset(nxt, -1, sizeof(nxt));
  memset(vis, false, sizeof(vis));

  while (!st.empty()) {
    auto [u, flag] = st.top();
    st.pop();

    if (flag) {
      if (adj[u].empty()) continue;
      int best = adj[u][0];
      for (int v : adj[u]) {
        if (cmp(v, best)) {
          best = v;
        }
      }
      nxt[u] = best;
    } else {
      st.push({u, true});
      for (auto it = adj[u].rbegin(); it != adj[u].rend(); ++it) {
        int v = *it;
        if (!vis[v]) {
          vis[v] = true;
          st.push({v, false});
        }
      }
    }
  }
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);

  cin >> n;
  string str;
  cin >> str;
  for (int i = 1; i <= n; ++i) {
    s[i] = str[i - 1];
  }

  for (int i = 0; i < n - 1; ++i) {
    int x, y;
    cin >> x >> y;
    adj[x].push_back(y);
  }
  postOrder();
  string ans;
  int cur = 1;
  while (cur != -1) {
    ans += s[cur];
    cur = nxt[cur];
  }
  cout << ans << endl;

  return 0;
}
```
_________________________________________     
C,D就不予显示，我也不会……~~不是蒟蒻也无奈~~
